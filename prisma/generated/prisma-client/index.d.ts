// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  aMActivity: (where?: AMActivityWhereInput) => Promise<boolean>;
  fieldTrip: (where?: FieldTripWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  studentSchedule: (where?: StudentScheduleWhereInput) => Promise<boolean>;
  summerSchedule: (where?: SummerScheduleWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  week: (where?: WeekWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  aMActivity: (where: AMActivityWhereUniqueInput) => AMActivityPromise;
  aMActivities: (
    args?: {
      where?: AMActivityWhereInput;
      orderBy?: AMActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AMActivity>;
  aMActivitiesConnection: (
    args?: {
      where?: AMActivityWhereInput;
      orderBy?: AMActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AMActivityConnectionPromise;
  fieldTrip: (where: FieldTripWhereUniqueInput) => FieldTripPromise;
  fieldTrips: (
    args?: {
      where?: FieldTripWhereInput;
      orderBy?: FieldTripOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FieldTrip>;
  fieldTripsConnection: (
    args?: {
      where?: FieldTripWhereInput;
      orderBy?: FieldTripOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FieldTripConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (
    args?: {
      where?: StudentWhereInput;
      orderBy?: StudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Student>;
  studentsConnection: (
    args?: {
      where?: StudentWhereInput;
      orderBy?: StudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StudentConnectionPromise;
  studentSchedule: (
    where: StudentScheduleWhereUniqueInput
  ) => StudentSchedulePromise;
  studentSchedules: (
    args?: {
      where?: StudentScheduleWhereInput;
      orderBy?: StudentScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StudentSchedule>;
  studentSchedulesConnection: (
    args?: {
      where?: StudentScheduleWhereInput;
      orderBy?: StudentScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StudentScheduleConnectionPromise;
  summerSchedule: (
    where: SummerScheduleWhereUniqueInput
  ) => SummerSchedulePromise;
  summerSchedules: (
    args?: {
      where?: SummerScheduleWhereInput;
      orderBy?: SummerScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SummerSchedule>;
  summerSchedulesConnection: (
    args?: {
      where?: SummerScheduleWhereInput;
      orderBy?: SummerScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SummerScheduleConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  week: (where: WeekWhereUniqueInput) => WeekPromise;
  weeks: (
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Week>;
  weeksConnection: (
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WeekConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAMActivity: (data: AMActivityCreateInput) => AMActivityPromise;
  updateAMActivity: (
    args: { data: AMActivityUpdateInput; where: AMActivityWhereUniqueInput }
  ) => AMActivityPromise;
  updateManyAMActivities: (
    args: {
      data: AMActivityUpdateManyMutationInput;
      where?: AMActivityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAMActivity: (
    args: {
      where: AMActivityWhereUniqueInput;
      create: AMActivityCreateInput;
      update: AMActivityUpdateInput;
    }
  ) => AMActivityPromise;
  deleteAMActivity: (where: AMActivityWhereUniqueInput) => AMActivityPromise;
  deleteManyAMActivities: (where?: AMActivityWhereInput) => BatchPayloadPromise;
  createFieldTrip: (data: FieldTripCreateInput) => FieldTripPromise;
  updateFieldTrip: (
    args: { data: FieldTripUpdateInput; where: FieldTripWhereUniqueInput }
  ) => FieldTripPromise;
  updateManyFieldTrips: (
    args: {
      data: FieldTripUpdateManyMutationInput;
      where?: FieldTripWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFieldTrip: (
    args: {
      where: FieldTripWhereUniqueInput;
      create: FieldTripCreateInput;
      update: FieldTripUpdateInput;
    }
  ) => FieldTripPromise;
  deleteFieldTrip: (where: FieldTripWhereUniqueInput) => FieldTripPromise;
  deleteManyFieldTrips: (where?: FieldTripWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (
    args: { data: StudentUpdateInput; where: StudentWhereUniqueInput }
  ) => StudentPromise;
  updateManyStudents: (
    args: { data: StudentUpdateManyMutationInput; where?: StudentWhereInput }
  ) => BatchPayloadPromise;
  upsertStudent: (
    args: {
      where: StudentWhereUniqueInput;
      create: StudentCreateInput;
      update: StudentUpdateInput;
    }
  ) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createStudentSchedule: (
    data: StudentScheduleCreateInput
  ) => StudentSchedulePromise;
  updateStudentSchedule: (
    args: {
      data: StudentScheduleUpdateInput;
      where: StudentScheduleWhereUniqueInput;
    }
  ) => StudentSchedulePromise;
  updateManyStudentSchedules: (
    args: {
      data: StudentScheduleUpdateManyMutationInput;
      where?: StudentScheduleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertStudentSchedule: (
    args: {
      where: StudentScheduleWhereUniqueInput;
      create: StudentScheduleCreateInput;
      update: StudentScheduleUpdateInput;
    }
  ) => StudentSchedulePromise;
  deleteStudentSchedule: (
    where: StudentScheduleWhereUniqueInput
  ) => StudentSchedulePromise;
  deleteManyStudentSchedules: (
    where?: StudentScheduleWhereInput
  ) => BatchPayloadPromise;
  createSummerSchedule: (
    data: SummerScheduleCreateInput
  ) => SummerSchedulePromise;
  updateSummerSchedule: (
    args: {
      data: SummerScheduleUpdateInput;
      where: SummerScheduleWhereUniqueInput;
    }
  ) => SummerSchedulePromise;
  updateManySummerSchedules: (
    args: {
      data: SummerScheduleUpdateManyMutationInput;
      where?: SummerScheduleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSummerSchedule: (
    args: {
      where: SummerScheduleWhereUniqueInput;
      create: SummerScheduleCreateInput;
      update: SummerScheduleUpdateInput;
    }
  ) => SummerSchedulePromise;
  deleteSummerSchedule: (
    where: SummerScheduleWhereUniqueInput
  ) => SummerSchedulePromise;
  deleteManySummerSchedules: (
    where?: SummerScheduleWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWeek: (data: WeekCreateInput) => WeekPromise;
  updateWeek: (
    args: { data: WeekUpdateInput; where: WeekWhereUniqueInput }
  ) => WeekPromise;
  updateManyWeeks: (
    args: { data: WeekUpdateManyMutationInput; where?: WeekWhereInput }
  ) => BatchPayloadPromise;
  upsertWeek: (
    args: {
      where: WeekWhereUniqueInput;
      create: WeekCreateInput;
      update: WeekUpdateInput;
    }
  ) => WeekPromise;
  deleteWeek: (where: WeekWhereUniqueInput) => WeekPromise;
  deleteManyWeeks: (where?: WeekWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  aMActivity: (
    where?: AMActivitySubscriptionWhereInput
  ) => AMActivitySubscriptionPayloadSubscription;
  fieldTrip: (
    where?: FieldTripSubscriptionWhereInput
  ) => FieldTripSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  studentSchedule: (
    where?: StudentScheduleSubscriptionWhereInput
  ) => StudentScheduleSubscriptionPayloadSubscription;
  summerSchedule: (
    where?: SummerScheduleSubscriptionWhereInput
  ) => SummerScheduleSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  week: (
    where?: WeekSubscriptionWhereInput
  ) => WeekSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type WeekOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weekNumber_ASC"
  | "weekNumber_DESC"
  | "year_ASC"
  | "year_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FieldTripOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Level = "PRESCHOOL" | "LOWER_ELEMENTARY" | "UPPER_ELEMENTARY";

export type StudentScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amCare_ASC"
  | "amCare_DESC"
  | "pmCare_ASC"
  | "pmCare_DESC"
  | "pmClass_ASC"
  | "pmClass_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "age_ASC"
  | "age_DESC"
  | "level_ASC"
  | "level_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AMActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ages_ASC"
  | "ages_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "price_ASC"
  | "price_DESC"
  | "title_ASC"
  | "title_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActivityType = "CAMP" | "CLASS";

export type SummerScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "level_ASC"
  | "level_DESC"
  | "year_ASC"
  | "year_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface WeekCreateOneInput {
  create?: WeekCreateInput;
  connect?: WeekWhereUniqueInput;
}

export type AMActivityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StudentScheduleUpdateManyWithWhereNestedInput {
  where: StudentScheduleScalarWhereInput;
  data: StudentScheduleUpdateManyDataInput;
}

export interface FieldTripUpdateDataInput {
  price?: Int;
  title?: String;
}

export interface StudentScheduleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amCare?: Boolean;
  amCare_not?: Boolean;
  pmCare?: Boolean;
  pmCare_not?: Boolean;
  pmClass?: Boolean;
  pmClass_not?: Boolean;
  AND?: StudentScheduleScalarWhereInput[] | StudentScheduleScalarWhereInput;
  OR?: StudentScheduleScalarWhereInput[] | StudentScheduleScalarWhereInput;
  NOT?: StudentScheduleScalarWhereInput[] | StudentScheduleScalarWhereInput;
}

export interface StudentScheduleUpdateWithWhereUniqueNestedInput {
  where: StudentScheduleWhereUniqueInput;
  data: StudentScheduleUpdateDataInput;
}

export type WeekWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FieldTripWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: FieldTripWhereInput[] | FieldTripWhereInput;
  OR?: FieldTripWhereInput[] | FieldTripWhereInput;
  NOT?: FieldTripWhereInput[] | FieldTripWhereInput;
}

export interface StudentScheduleUpsertWithWhereUniqueNestedInput {
  where: StudentScheduleWhereUniqueInput;
  update: StudentScheduleUpdateDataInput;
  create: StudentScheduleCreateInput;
}

export interface SummerScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SummerScheduleWhereInput;
  AND?:
    | SummerScheduleSubscriptionWhereInput[]
    | SummerScheduleSubscriptionWhereInput;
  OR?:
    | SummerScheduleSubscriptionWhereInput[]
    | SummerScheduleSubscriptionWhereInput;
  NOT?:
    | SummerScheduleSubscriptionWhereInput[]
    | SummerScheduleSubscriptionWhereInput;
}

export interface WeekUpsertNestedInput {
  update: WeekUpdateDataInput;
  create: WeekCreateInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface FieldTripUpdateManyDataInput {
  price?: Int;
  title?: String;
}

export interface FieldTripSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldTripWhereInput;
  AND?: FieldTripSubscriptionWhereInput[] | FieldTripSubscriptionWhereInput;
  OR?: FieldTripSubscriptionWhereInput[] | FieldTripSubscriptionWhereInput;
  NOT?: FieldTripSubscriptionWhereInput[] | FieldTripSubscriptionWhereInput;
}

export interface StudentScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amCare?: Boolean;
  amCare_not?: Boolean;
  pmCare?: Boolean;
  pmCare_not?: Boolean;
  pmClass?: Boolean;
  pmClass_not?: Boolean;
  week?: WeekWhereInput;
  AND?: StudentScheduleWhereInput[] | StudentScheduleWhereInput;
  OR?: StudentScheduleWhereInput[] | StudentScheduleWhereInput;
  NOT?: StudentScheduleWhereInput[] | StudentScheduleWhereInput;
}

export interface WeekUpdateManyMutationInput {
  weekNumber?: Int;
  year?: Int;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface AMActivityCreateInput {
  ages?: String;
  desc?: String;
  price?: Int;
  title: String;
  type?: ActivityType;
}

export interface UserUpdateManyMutationInput {
  name?: String;
}

export interface AMActivityUpdateInput {
  ages?: String;
  desc?: String;
  price?: Int;
  title?: String;
  type?: ActivityType;
}

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  age?: Int;
  age_not?: Int;
  age_in?: Int[] | Int;
  age_not_in?: Int[] | Int;
  age_lt?: Int;
  age_lte?: Int;
  age_gt?: Int;
  age_gte?: Int;
  level?: Level;
  level_not?: Level;
  level_in?: Level[] | Level;
  level_not_in?: Level[] | Level;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  scheduleList_every?: StudentScheduleWhereInput;
  scheduleList_some?: StudentScheduleWhereInput;
  scheduleList_none?: StudentScheduleWhereInput;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface AMActivityUpdateManyMutationInput {
  ages?: String;
  desc?: String;
  price?: Int;
  title?: String;
  type?: ActivityType;
}

export interface SummerScheduleUpdateManyMutationInput {
  level?: Level;
  year?: Int;
}

export interface FieldTripUpdateManyWithWhereNestedInput {
  where: FieldTripScalarWhereInput;
  data: FieldTripUpdateManyDataInput;
}

export interface WeekUpdateManyWithWhereNestedInput {
  where: WeekScalarWhereInput;
  data: WeekUpdateManyDataInput;
}

export interface FieldTripScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: FieldTripScalarWhereInput[] | FieldTripScalarWhereInput;
  OR?: FieldTripScalarWhereInput[] | FieldTripScalarWhereInput;
  NOT?: FieldTripScalarWhereInput[] | FieldTripScalarWhereInput;
}

export interface WeekScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weekNumber?: Int;
  weekNumber_not?: Int;
  weekNumber_in?: Int[] | Int;
  weekNumber_not_in?: Int[] | Int;
  weekNumber_lt?: Int;
  weekNumber_lte?: Int;
  weekNumber_gt?: Int;
  weekNumber_gte?: Int;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  AND?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  OR?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  NOT?: WeekScalarWhereInput[] | WeekScalarWhereInput;
}

export interface FieldTripCreateInput {
  price?: Int;
  title: String;
}

export interface WeekUpdateWithWhereUniqueNestedInput {
  where: WeekWhereUniqueInput;
  data: WeekUpdateDataInput;
}

export interface FieldTripUpdateInput {
  price?: Int;
  title?: String;
}

export interface WeekUpdateManyInput {
  create?: WeekCreateInput[] | WeekCreateInput;
  update?:
    | WeekUpdateWithWhereUniqueNestedInput[]
    | WeekUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WeekUpsertWithWhereUniqueNestedInput[]
    | WeekUpsertWithWhereUniqueNestedInput;
  delete?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  connect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  set?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  disconnect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  deleteMany?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  updateMany?:
    | WeekUpdateManyWithWhereNestedInput[]
    | WeekUpdateManyWithWhereNestedInput;
}

export interface FieldTripUpdateManyMutationInput {
  price?: Int;
  title?: String;
}

export interface SummerScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  level?: Level;
  level_not?: Level;
  level_in?: Level[] | Level;
  level_not_in?: Level[] | Level;
  weekList_every?: WeekWhereInput;
  weekList_some?: WeekWhereInput;
  weekList_none?: WeekWhereInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  AND?: SummerScheduleWhereInput[] | SummerScheduleWhereInput;
  OR?: SummerScheduleWhereInput[] | SummerScheduleWhereInput;
  NOT?: SummerScheduleWhereInput[] | SummerScheduleWhereInput;
}

export interface StudentCreateInput {
  age: Int;
  level: Level;
  name: String;
  scheduleList?: StudentScheduleCreateManyInput;
}

export interface WeekCreateManyInput {
  create?: WeekCreateInput[] | WeekCreateInput;
  connect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
}

export interface StudentScheduleCreateManyInput {
  create?: StudentScheduleCreateInput[] | StudentScheduleCreateInput;
  connect?: StudentScheduleWhereUniqueInput[] | StudentScheduleWhereUniqueInput;
}

export interface StudentScheduleUpdateManyMutationInput {
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
}

export interface StudentScheduleCreateInput {
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
  week: WeekCreateOneInput;
}

export interface StudentScheduleUpdateInput {
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
  week?: WeekUpdateOneRequiredInput;
}

export interface FieldTripUpsertWithWhereUniqueNestedInput {
  where: FieldTripWhereUniqueInput;
  update: FieldTripUpdateDataInput;
  create: FieldTripCreateInput;
}

export interface StudentUpdateManyMutationInput {
  age?: Int;
  level?: Level;
  name?: String;
}

export interface WeekCreateInput {
  weekNumber: Int;
  year?: Int;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  AM_Activity?: AMActivityCreateManyInput;
  fieldTripList?: FieldTripCreateManyInput;
}

export interface WeekSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WeekWhereInput;
  AND?: WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput;
  OR?: WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput;
  NOT?: WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput;
}

export interface AMActivityCreateManyInput {
  create?: AMActivityCreateInput[] | AMActivityCreateInput;
  connect?: AMActivityWhereUniqueInput[] | AMActivityWhereUniqueInput;
}

export interface StudentScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentScheduleWhereInput;
  AND?:
    | StudentScheduleSubscriptionWhereInput[]
    | StudentScheduleSubscriptionWhereInput;
  OR?:
    | StudentScheduleSubscriptionWhereInput[]
    | StudentScheduleSubscriptionWhereInput;
  NOT?:
    | StudentScheduleSubscriptionWhereInput[]
    | StudentScheduleSubscriptionWhereInput;
}

export interface FieldTripCreateManyInput {
  create?: FieldTripCreateInput[] | FieldTripCreateInput;
  connect?: FieldTripWhereUniqueInput[] | FieldTripWhereUniqueInput;
}

export interface AMActivitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AMActivityWhereInput;
  AND?: AMActivitySubscriptionWhereInput[] | AMActivitySubscriptionWhereInput;
  OR?: AMActivitySubscriptionWhereInput[] | AMActivitySubscriptionWhereInput;
  NOT?: AMActivitySubscriptionWhereInput[] | AMActivitySubscriptionWhereInput;
}

export interface StudentUpdateInput {
  age?: Int;
  level?: Level;
  name?: String;
  scheduleList?: StudentScheduleUpdateManyInput;
}

export interface WeekUpdateInput {
  weekNumber?: Int;
  year?: Int;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  AM_Activity?: AMActivityUpdateManyInput;
  fieldTripList?: FieldTripUpdateManyInput;
}

export interface StudentScheduleUpdateManyInput {
  create?: StudentScheduleCreateInput[] | StudentScheduleCreateInput;
  update?:
    | StudentScheduleUpdateWithWhereUniqueNestedInput[]
    | StudentScheduleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StudentScheduleUpsertWithWhereUniqueNestedInput[]
    | StudentScheduleUpsertWithWhereUniqueNestedInput;
  delete?: StudentScheduleWhereUniqueInput[] | StudentScheduleWhereUniqueInput;
  connect?: StudentScheduleWhereUniqueInput[] | StudentScheduleWhereUniqueInput;
  set?: StudentScheduleWhereUniqueInput[] | StudentScheduleWhereUniqueInput;
  disconnect?:
    | StudentScheduleWhereUniqueInput[]
    | StudentScheduleWhereUniqueInput;
  deleteMany?:
    | StudentScheduleScalarWhereInput[]
    | StudentScheduleScalarWhereInput;
  updateMany?:
    | StudentScheduleUpdateManyWithWhereNestedInput[]
    | StudentScheduleUpdateManyWithWhereNestedInput;
}

export interface UserCreateInput {
  name: String;
}

export type FieldTripWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type StudentScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StudentScheduleUpdateDataInput {
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
  week?: WeekUpdateOneRequiredInput;
}

export type SummerScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface WeekUpdateOneRequiredInput {
  create?: WeekCreateInput;
  update?: WeekUpdateDataInput;
  upsert?: WeekUpsertNestedInput;
  connect?: WeekWhereUniqueInput;
}

export interface SummerScheduleUpdateInput {
  level?: Level;
  weekList?: WeekUpdateManyInput;
  year?: Int;
}

export interface WeekUpdateDataInput {
  weekNumber?: Int;
  year?: Int;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  AM_Activity?: AMActivityUpdateManyInput;
  fieldTripList?: FieldTripUpdateManyInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AMActivityUpdateManyInput {
  create?: AMActivityCreateInput[] | AMActivityCreateInput;
  update?:
    | AMActivityUpdateWithWhereUniqueNestedInput[]
    | AMActivityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AMActivityUpsertWithWhereUniqueNestedInput[]
    | AMActivityUpsertWithWhereUniqueNestedInput;
  delete?: AMActivityWhereUniqueInput[] | AMActivityWhereUniqueInput;
  connect?: AMActivityWhereUniqueInput[] | AMActivityWhereUniqueInput;
  set?: AMActivityWhereUniqueInput[] | AMActivityWhereUniqueInput;
  disconnect?: AMActivityWhereUniqueInput[] | AMActivityWhereUniqueInput;
  deleteMany?: AMActivityScalarWhereInput[] | AMActivityScalarWhereInput;
  updateMany?:
    | AMActivityUpdateManyWithWhereNestedInput[]
    | AMActivityUpdateManyWithWhereNestedInput;
}

export interface StudentScheduleUpdateManyDataInput {
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
}

export interface AMActivityUpdateWithWhereUniqueNestedInput {
  where: AMActivityWhereUniqueInput;
  data: AMActivityUpdateDataInput;
}

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AMActivityUpdateDataInput {
  ages?: String;
  desc?: String;
  price?: Int;
  title?: String;
  type?: ActivityType;
}

export interface UserUpdateInput {
  name?: String;
}

export interface AMActivityUpsertWithWhereUniqueNestedInput {
  where: AMActivityWhereUniqueInput;
  update: AMActivityUpdateDataInput;
  create: AMActivityCreateInput;
}

export interface WeekUpsertWithWhereUniqueNestedInput {
  where: WeekWhereUniqueInput;
  update: WeekUpdateDataInput;
  create: WeekCreateInput;
}

export interface AMActivityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  ages?: String;
  ages_not?: String;
  ages_in?: String[] | String;
  ages_not_in?: String[] | String;
  ages_lt?: String;
  ages_lte?: String;
  ages_gt?: String;
  ages_gte?: String;
  ages_contains?: String;
  ages_not_contains?: String;
  ages_starts_with?: String;
  ages_not_starts_with?: String;
  ages_ends_with?: String;
  ages_not_ends_with?: String;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  type?: ActivityType;
  type_not?: ActivityType;
  type_in?: ActivityType[] | ActivityType;
  type_not_in?: ActivityType[] | ActivityType;
  AND?: AMActivityScalarWhereInput[] | AMActivityScalarWhereInput;
  OR?: AMActivityScalarWhereInput[] | AMActivityScalarWhereInput;
  NOT?: AMActivityScalarWhereInput[] | AMActivityScalarWhereInput;
}

export interface SummerScheduleCreateInput {
  level?: Level;
  weekList?: WeekCreateManyInput;
  year?: Int;
}

export interface FieldTripUpdateWithWhereUniqueNestedInput {
  where: FieldTripWhereUniqueInput;
  data: FieldTripUpdateDataInput;
}

export interface FieldTripUpdateManyInput {
  create?: FieldTripCreateInput[] | FieldTripCreateInput;
  update?:
    | FieldTripUpdateWithWhereUniqueNestedInput[]
    | FieldTripUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FieldTripUpsertWithWhereUniqueNestedInput[]
    | FieldTripUpsertWithWhereUniqueNestedInput;
  delete?: FieldTripWhereUniqueInput[] | FieldTripWhereUniqueInput;
  connect?: FieldTripWhereUniqueInput[] | FieldTripWhereUniqueInput;
  set?: FieldTripWhereUniqueInput[] | FieldTripWhereUniqueInput;
  disconnect?: FieldTripWhereUniqueInput[] | FieldTripWhereUniqueInput;
  deleteMany?: FieldTripScalarWhereInput[] | FieldTripScalarWhereInput;
  updateMany?:
    | FieldTripUpdateManyWithWhereNestedInput[]
    | FieldTripUpdateManyWithWhereNestedInput;
}

export interface AMActivityUpdateManyDataInput {
  ages?: String;
  desc?: String;
  price?: Int;
  title?: String;
  type?: ActivityType;
}

export interface AMActivityUpdateManyWithWhereNestedInput {
  where: AMActivityScalarWhereInput;
  data: AMActivityUpdateManyDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AMActivityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  ages?: String;
  ages_not?: String;
  ages_in?: String[] | String;
  ages_not_in?: String[] | String;
  ages_lt?: String;
  ages_lte?: String;
  ages_gt?: String;
  ages_gte?: String;
  ages_contains?: String;
  ages_not_contains?: String;
  ages_starts_with?: String;
  ages_not_starts_with?: String;
  ages_ends_with?: String;
  ages_not_ends_with?: String;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  type?: ActivityType;
  type_not?: ActivityType;
  type_in?: ActivityType[] | ActivityType;
  type_not_in?: ActivityType[] | ActivityType;
  AND?: AMActivityWhereInput[] | AMActivityWhereInput;
  OR?: AMActivityWhereInput[] | AMActivityWhereInput;
  NOT?: AMActivityWhereInput[] | AMActivityWhereInput;
}

export interface WeekUpdateManyDataInput {
  weekNumber?: Int;
  year?: Int;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface WeekWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weekNumber?: Int;
  weekNumber_not?: Int;
  weekNumber_in?: Int[] | Int;
  weekNumber_not_in?: Int[] | Int;
  weekNumber_lt?: Int;
  weekNumber_lte?: Int;
  weekNumber_gt?: Int;
  weekNumber_gte?: Int;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  AM_Activity_every?: AMActivityWhereInput;
  AM_Activity_some?: AMActivityWhereInput;
  AM_Activity_none?: AMActivityWhereInput;
  fieldTripList_every?: FieldTripWhereInput;
  fieldTripList_some?: FieldTripWhereInput;
  fieldTripList_none?: FieldTripWhereInput;
  AND?: WeekWhereInput[] | WeekWhereInput;
  OR?: WeekWhereInput[] | WeekWhereInput;
  NOT?: WeekWhereInput[] | WeekWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WeekPreviousValues {
  id: ID_Output;
  weekNumber: Int;
  year?: Int;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface WeekPreviousValuesPromise
  extends Promise<WeekPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weekNumber: () => Promise<Int>;
  year: () => Promise<Int>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface WeekPreviousValuesSubscription
  extends Promise<AsyncIterator<WeekPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weekNumber: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudentSchedule {
  id: ID_Output;
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
}

export interface StudentSchedulePromise
  extends Promise<StudentSchedule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amCare: () => Promise<Boolean>;
  pmCare: () => Promise<Boolean>;
  pmClass: () => Promise<Boolean>;
  week: <T = WeekPromise>() => T;
}

export interface StudentScheduleSubscription
  extends Promise<AsyncIterator<StudentSchedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amCare: () => Promise<AsyncIterator<Boolean>>;
  pmCare: () => Promise<AsyncIterator<Boolean>>;
  pmClass: () => Promise<AsyncIterator<Boolean>>;
  week: <T = WeekSubscription>() => T;
}

export interface AggregateAMActivity {
  count: Int;
}

export interface AggregateAMActivityPromise
  extends Promise<AggregateAMActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAMActivitySubscription
  extends Promise<AsyncIterator<AggregateAMActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AMActivityEdge {
  node: AMActivity;
  cursor: String;
}

export interface AMActivityEdgePromise
  extends Promise<AMActivityEdge>,
    Fragmentable {
  node: <T = AMActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AMActivityEdgeSubscription
  extends Promise<AsyncIterator<AMActivityEdge>>,
    Fragmentable {
  node: <T = AMActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWeek {
  count: Int;
}

export interface AggregateWeekPromise
  extends Promise<AggregateWeek>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeekSubscription
  extends Promise<AsyncIterator<AggregateWeek>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WeekEdge {
  node: Week;
  cursor: String;
}

export interface WeekEdgePromise extends Promise<WeekEdge>, Fragmentable {
  node: <T = WeekPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeekEdgeSubscription
  extends Promise<AsyncIterator<WeekEdge>>,
    Fragmentable {
  node: <T = WeekSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WeekConnection {
  pageInfo: PageInfo;
  edges: WeekEdge[];
}

export interface WeekConnectionPromise
  extends Promise<WeekConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeekEdge>>() => T;
  aggregate: <T = AggregateWeekPromise>() => T;
}

export interface WeekConnectionSubscription
  extends Promise<AsyncIterator<WeekConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeekEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeekSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface WeekSubscriptionPayload {
  mutation: MutationType;
  node: Week;
  updatedFields: String[];
  previousValues: WeekPreviousValues;
}

export interface WeekSubscriptionPayloadPromise
  extends Promise<WeekSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeekPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeekPreviousValuesPromise>() => T;
}

export interface WeekSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeekSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeekSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeekPreviousValuesSubscription>() => T;
}

export interface AMActivity {
  id: ID_Output;
  ages?: String;
  desc?: String;
  price: Int;
  title: String;
  type: ActivityType;
}

export interface AMActivityPromise extends Promise<AMActivity>, Fragmentable {
  id: () => Promise<ID_Output>;
  ages: () => Promise<String>;
  desc: () => Promise<String>;
  price: () => Promise<Int>;
  title: () => Promise<String>;
  type: () => Promise<ActivityType>;
}

export interface AMActivitySubscription
  extends Promise<AsyncIterator<AMActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ages: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ActivityType>>;
}

export interface AggregateSummerSchedule {
  count: Int;
}

export interface AggregateSummerSchedulePromise
  extends Promise<AggregateSummerSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSummerScheduleSubscription
  extends Promise<AsyncIterator<AggregateSummerSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AMActivitySubscriptionPayload {
  mutation: MutationType;
  node: AMActivity;
  updatedFields: String[];
  previousValues: AMActivityPreviousValues;
}

export interface AMActivitySubscriptionPayloadPromise
  extends Promise<AMActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AMActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AMActivityPreviousValuesPromise>() => T;
}

export interface AMActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AMActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AMActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AMActivityPreviousValuesSubscription>() => T;
}

export interface SummerScheduleConnection {
  pageInfo: PageInfo;
  edges: SummerScheduleEdge[];
}

export interface SummerScheduleConnectionPromise
  extends Promise<SummerScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SummerScheduleEdge>>() => T;
  aggregate: <T = AggregateSummerSchedulePromise>() => T;
}

export interface SummerScheduleConnectionSubscription
  extends Promise<AsyncIterator<SummerScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SummerScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSummerScheduleSubscription>() => T;
}

export interface AMActivityPreviousValues {
  id: ID_Output;
  ages?: String;
  desc?: String;
  price: Int;
  title: String;
  type: ActivityType;
}

export interface AMActivityPreviousValuesPromise
  extends Promise<AMActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ages: () => Promise<String>;
  desc: () => Promise<String>;
  price: () => Promise<Int>;
  title: () => Promise<String>;
  type: () => Promise<ActivityType>;
}

export interface AMActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<AMActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ages: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ActivityType>>;
}

export interface SummerSchedule {
  id: ID_Output;
  level: Level;
  year?: Int;
}

export interface SummerSchedulePromise
  extends Promise<SummerSchedule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  level: () => Promise<Level>;
  weekList: <T = FragmentableArray<Week>>(
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  year: () => Promise<Int>;
}

export interface SummerScheduleSubscription
  extends Promise<AsyncIterator<SummerSchedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  level: () => Promise<AsyncIterator<Level>>;
  weekList: <T = Promise<AsyncIterator<WeekSubscription>>>(
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  year: () => Promise<AsyncIterator<Int>>;
}

export interface Student {
  id: ID_Output;
  age: Int;
  level: Level;
  name: String;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  age: () => Promise<Int>;
  level: () => Promise<Level>;
  name: () => Promise<String>;
  scheduleList: <T = FragmentableArray<StudentSchedule>>(
    args?: {
      where?: StudentScheduleWhereInput;
      orderBy?: StudentScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  age: () => Promise<AsyncIterator<Int>>;
  level: () => Promise<AsyncIterator<Level>>;
  name: () => Promise<AsyncIterator<String>>;
  scheduleList: <T = Promise<AsyncIterator<StudentScheduleSubscription>>>(
    args?: {
      where?: StudentScheduleWhereInput;
      orderBy?: StudentScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StudentScheduleEdge {
  node: StudentSchedule;
  cursor: String;
}

export interface StudentScheduleEdgePromise
  extends Promise<StudentScheduleEdge>,
    Fragmentable {
  node: <T = StudentSchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentScheduleEdgeSubscription
  extends Promise<AsyncIterator<StudentScheduleEdge>>,
    Fragmentable {
  node: <T = StudentScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FieldTripSubscriptionPayload {
  mutation: MutationType;
  node: FieldTrip;
  updatedFields: String[];
  previousValues: FieldTripPreviousValues;
}

export interface FieldTripSubscriptionPayloadPromise
  extends Promise<FieldTripSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldTripPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldTripPreviousValuesPromise>() => T;
}

export interface FieldTripSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldTripSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldTripSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldTripPreviousValuesSubscription>() => T;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldTripPreviousValues {
  id: ID_Output;
  price: Int;
  title: String;
}

export interface FieldTripPreviousValuesPromise
  extends Promise<FieldTripPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
  title: () => Promise<String>;
}

export interface FieldTripPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldTripPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface AggregateFieldTrip {
  count: Int;
}

export interface AggregateFieldTripPromise
  extends Promise<AggregateFieldTrip>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldTripSubscription
  extends Promise<AsyncIterator<AggregateFieldTrip>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Week {
  id: ID_Output;
  weekNumber: Int;
  year?: Int;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface WeekPromise extends Promise<Week>, Fragmentable {
  id: () => Promise<ID_Output>;
  weekNumber: () => Promise<Int>;
  year: () => Promise<Int>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  AM_Activity: <T = FragmentableArray<AMActivity>>(
    args?: {
      where?: AMActivityWhereInput;
      orderBy?: AMActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fieldTripList: <T = FragmentableArray<FieldTrip>>(
    args?: {
      where?: FieldTripWhereInput;
      orderBy?: FieldTripOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WeekSubscription
  extends Promise<AsyncIterator<Week>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weekNumber: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  AM_Activity: <T = Promise<AsyncIterator<AMActivitySubscription>>>(
    args?: {
      where?: AMActivityWhereInput;
      orderBy?: AMActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fieldTripList: <T = Promise<AsyncIterator<FieldTripSubscription>>>(
    args?: {
      where?: FieldTripWhereInput;
      orderBy?: FieldTripOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  age: Int;
  level: Level;
  name: String;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  age: () => Promise<Int>;
  level: () => Promise<Level>;
  name: () => Promise<String>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  age: () => Promise<AsyncIterator<Int>>;
  level: () => Promise<AsyncIterator<Level>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SummerScheduleEdge {
  node: SummerSchedule;
  cursor: String;
}

export interface SummerScheduleEdgePromise
  extends Promise<SummerScheduleEdge>,
    Fragmentable {
  node: <T = SummerSchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SummerScheduleEdgeSubscription
  extends Promise<AsyncIterator<SummerScheduleEdge>>,
    Fragmentable {
  node: <T = SummerScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FieldTripEdge {
  node: FieldTrip;
  cursor: String;
}

export interface FieldTripEdgePromise
  extends Promise<FieldTripEdge>,
    Fragmentable {
  node: <T = FieldTripPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldTripEdgeSubscription
  extends Promise<AsyncIterator<FieldTripEdge>>,
    Fragmentable {
  node: <T = FieldTripSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudentSchedule {
  count: Int;
}

export interface AggregateStudentSchedulePromise
  extends Promise<AggregateStudentSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentScheduleSubscription
  extends Promise<AsyncIterator<AggregateStudentSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentScheduleSubscriptionPayload {
  mutation: MutationType;
  node: StudentSchedule;
  updatedFields: String[];
  previousValues: StudentSchedulePreviousValues;
}

export interface StudentScheduleSubscriptionPayloadPromise
  extends Promise<StudentScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentSchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentSchedulePreviousValuesPromise>() => T;
}

export interface StudentScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentSchedulePreviousValuesSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SummerSchedulePreviousValues {
  id: ID_Output;
  level: Level;
  year?: Int;
}

export interface SummerSchedulePreviousValuesPromise
  extends Promise<SummerSchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  level: () => Promise<Level>;
  year: () => Promise<Int>;
}

export interface SummerSchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SummerSchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  level: () => Promise<AsyncIterator<Level>>;
  year: () => Promise<AsyncIterator<Int>>;
}

export interface SummerScheduleSubscriptionPayload {
  mutation: MutationType;
  node: SummerSchedule;
  updatedFields: String[];
  previousValues: SummerSchedulePreviousValues;
}

export interface SummerScheduleSubscriptionPayloadPromise
  extends Promise<SummerScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SummerSchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SummerSchedulePreviousValuesPromise>() => T;
}

export interface SummerScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SummerScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SummerScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SummerSchedulePreviousValuesSubscription>() => T;
}

export interface FieldTripConnection {
  pageInfo: PageInfo;
  edges: FieldTripEdge[];
}

export interface FieldTripConnectionPromise
  extends Promise<FieldTripConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldTripEdge>>() => T;
  aggregate: <T = AggregateFieldTripPromise>() => T;
}

export interface FieldTripConnectionSubscription
  extends Promise<AsyncIterator<FieldTripConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldTripEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldTripSubscription>() => T;
}

export interface StudentSchedulePreviousValues {
  id: ID_Output;
  amCare?: Boolean;
  pmCare?: Boolean;
  pmClass?: Boolean;
}

export interface StudentSchedulePreviousValuesPromise
  extends Promise<StudentSchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amCare: () => Promise<Boolean>;
  pmCare: () => Promise<Boolean>;
  pmClass: () => Promise<Boolean>;
}

export interface StudentSchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<StudentSchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amCare: () => Promise<AsyncIterator<Boolean>>;
  pmCare: () => Promise<AsyncIterator<Boolean>>;
  pmClass: () => Promise<AsyncIterator<Boolean>>;
}

export interface User {
  id: ID_Output;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AMActivityConnection {
  pageInfo: PageInfo;
  edges: AMActivityEdge[];
}

export interface AMActivityConnectionPromise
  extends Promise<AMActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AMActivityEdge>>() => T;
  aggregate: <T = AggregateAMActivityPromise>() => T;
}

export interface AMActivityConnectionSubscription
  extends Promise<AsyncIterator<AMActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AMActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAMActivitySubscription>() => T;
}

export interface StudentScheduleConnection {
  pageInfo: PageInfo;
  edges: StudentScheduleEdge[];
}

export interface StudentScheduleConnectionPromise
  extends Promise<StudentScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentScheduleEdge>>() => T;
  aggregate: <T = AggregateStudentSchedulePromise>() => T;
}

export interface StudentScheduleConnectionSubscription
  extends Promise<AsyncIterator<StudentScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentScheduleSubscription>() => T;
}

export interface FieldTrip {
  id: ID_Output;
  price: Int;
  title: String;
}

export interface FieldTripPromise extends Promise<FieldTrip>, Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
  title: () => Promise<String>;
}

export interface FieldTripSubscription
  extends Promise<AsyncIterator<FieldTrip>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "SummerSchedule",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "StudentSchedule",
    embedded: false
  },
  {
    name: "Week",
    embedded: false
  },
  {
    name: "AMActivity",
    embedded: false
  },
  {
    name: "FieldTrip",
    embedded: false
  },
  {
    name: "ActivityType",
    embedded: false
  },
  {
    name: "Level",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
